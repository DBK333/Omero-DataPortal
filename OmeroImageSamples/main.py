# -*- coding: utf-8 -*-
"""main.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HEwDK4Tevau4f4RYitPMgWAI6APTwZl1

# Load libraries

CZI is storing raw data directly from Zeiss imaging systems
TIFF is an open, widely-used image format, for saving processed data after transformations like deskewing, denoising, or segmentation
ZARR is chunked, compressed, and scalable data format for multidimensional arrays. Often used in bioinformatics and large-scale imaging workflows
"""

pip install czifile

pip install tifffile

!pip install zarr

pip install aicsimageio

pip install python-bioformats

pip install pylibczirw

try:
  import google.colab
  IN_COLAB = True
except:
  IN_COLAB = False

if IN_COLAB:
    # Install pylibCZIrw and dependencies
    ! pip install --upgrade pip
    ! pip install pylibCZIrw cztile matplotlib tqdm scikit-image pooch requests

"""# Read raw images"""

from czifile import CziFile
import matplotlib.pyplot as plt
import numpy as np

from skimage import restoration
from skimage.filters import gaussian
from scipy.ndimage import affine_transform

import tifffile as tiff
from math import ceil

from pylibCZIrw import czi as pyczi
import json
import matplotlib.cm as cm
import os, sys
from tqdm import tqdm
from tqdm.contrib import itertools as it
from matplotlib.patches import Rectangle
from lxml import etree

# Specify Path
output_path_czi = ""
output_path_tiff = ""
output_path_zarr = ""

# Load .czi file
with CziFile(output_path_czi) as czi:
    czi_image = czi.asarray()
    plt.imshow(czi_image[0, 0, 0, :, :])  #, cmap='gray' # Adjust dimensions accordingly
    plt.show()

# Read the saved TIFF file
tiff_image = tiff.imread(output_path)

# Display the loaded image
plt.imshow(tiff_image) #, cmap='gray'
plt.title("Loaded Deskewed/Deconvolved Image")
plt.axis('off')
plt.show()

# Load the Zarr file
zarr_image = zarr.load(output_path_zarr)

# Display the image (adjust slicing as needed)
plt.imshow(zarr_image[0, 0, 0, :, :])
plt.title("Loaded Image from Zarr")
plt.axis('off')
plt.show()

"""# Get embedded metadata (from researchers)

Can be found in .czi or .zarr files
"""

# Open the CZI file and extract the image data
with CziFile(output_path_czi) as czi:
    # Extract metadata
    metadata = czi.metadata()
    # Display the metadata
    ## print("Metadata:")
    ## print(metadata)

"""# Deskew Images

Correct the angular distortion introduced during certain imaging techniques, especially in light-sheet microscopy (e.g., lattice light-sheet microscopy)
"""

# Deskewing parameters (modify based on actual acquisition)
skew_angle = 30  # Verify the correct angle
skew_factor = np.tan(np.deg2rad(skew_angle))

# Create transformation matrix for deskewing
transform_matrix = np.array([
    [1, 0, 0],             # X remains unchanged
    [skew_factor, 1, 0],   # Y skew correction
    [0, 0, 1]              # Z remains unchanged
])

# Select a 2D slice (adjust index as needed)
slice_2d = image[0, :, :, :, :]  # Example: Selecting the first element along axis 0 and all elements along other axes
#Adjust dimensions of slice_2d to 2D as needed
slice_2d = slice_2d[0,0,:,:]

# Pad the image to prevent cutoff after deskewing
# Modified pad_width to include padding for all 3 dimensions of slice_2d
padded_image = np.pad(slice_2d, ((0, 0), (0, 500), (0, 0)), mode='constant')

# Apply affine transformation with bilinear interpolation
deskewed_image = affine_transform(padded_image, transform_matrix, order=1)

# Display the deskewed image
plt.imshow(deskewed_image) #, cmap='gray'
plt.title("Deskewed Image")
plt.axis('off')
plt.show()

"""# Deconvolved Images"""

# Simulated point spread function (PSF)
psf = np.ones((5, 5)) / 25  # Uniform PSF; adjust size for your data

# Select a 2D slice (adjust index as needed)
slice_2d = image[417, :, :]  # Replace with the desired slice

# Optionally apply a Gaussian blur to simulate noise reduction
blurred_image = gaussian(slice_2d, sigma=1)

# Perform Richardson-Lucy deconvolution
deconvolved_image = restoration.richardson_lucy(blurred_image, psf, num_iter=30)

# Display the original and deconvolved images
plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
plt.imshow(slice_2d, cmap='gray')
plt.title("Original Image")
plt.axis('off')

plt.subplot(1, 2, 2)
plt.imshow(deconvolved_image, cmap='gray')
plt.title("Deconvolved Image")
plt.axis('off')

plt.tight_layout()
plt.show()

"""# Subsetting Images"""

sub_image = image[:, :, 100:500, 100:500]  # Subset spatially

# Assuming sub_image has dimensions (Time, Channel, Z, Y, X)
timepoint = 0  # Select the first timepoint
channel = 0    # Select the first channel
z_index = sub_image.shape[2] // 2  # Middle Z-slice

# Extract a 2D slice (Y, X) from the subset
slice_2d = sub_image[timepoint, channel, z_index, :, :]

# Display the 2D slice
plt.imshow(slice_2d)
plt.title("Subset Image")
plt.axis('off')
plt.show()

"""# Downsampling Images

Downsampling is the process of reducing the resolution of an image or dataset by decreasing the number of pixels in spatial dimensions. This is to Reduce File Size and Memory Usage, Improve Processing Speed, Facilitate Visualization, Prepare for Multi-Scale Analysis, Reduce Noise.
When fine details are critical for the task (e.g., in medical imaging or microscopy for cell analysis) then do not use this.
"""

from skimage.transform import resize

# Assume the image has dimensions (Time, Channel, Z, Y, X)
# Example input shape: (3, 1, 100, 512, 512)
timepoint = 0  # Select the first timepoint
channel = 0    # Select the first channel

# Resize only the spatial dimensions (Z, Y, X)
resized_image = resize(
    image,
    (
        image.shape[0],         # Keep Time dimension unchanged
        image.shape[1],         # Keep Channel dimension unchanged
        image.shape[2] // 2,    # Resize Z dimension
        image.shape[3] // 4,    # Resize Y dimension
        image.shape[4] // 4     # Resize X dimension
    ),
    preserve_range=True  # Preserve the original intensity range
)

# Display a slice from the resized image
z_index = resized_image.shape[2] // 2  # Middle Z-slice
slice_2d = resized_image[timepoint, channel, z_index, :, :]  # Extract (Y, X)

# Show the resized slice
plt.imshow(slice_2d, cmap='gray')
plt.title("Resized Image Slice")
plt.axis('off')
plt.show()

"""# Save or convert to TIFF"""

# Save the deconvolved image to a TIFF file
output_path_to_tiff
tiff.imwrite(output_path_to_tiff, deskewed_image.astype(np.float32))

"""# Save or convert to zarr"""

zarr_output_path = ""
zarr.save(zarr_output_path, image)